<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" title="theme" href="#">
    <link rel="stylesheet" href="css/styles/googlecode.css">
    <title>Example</title>
</head>
<body>
    <div class="container">
        <div class="inner__header">
            <div class="main-text">MY WORKSPACE</div>
            <div class="theme">
                <svg class="changeTheme" data-theme="light" width="40" height="40" viewBox="0 0 40 40" fill="black" xmlns="http://www.w3.org/2000/svg"> <path d="M20 30C22.6522 30 25.1957 28.9464 27.0711 27.0711C28.9464 25.1957 30 22.6522 30 20C30 17.3478 28.9464 14.8043 27.0711 12.9289C25.1957 11.0536 22.6522 10 20 10C17.3478 10 14.8043 11.0536 12.9289 12.9289C11.0536 14.8043 10 17.3478 10 20C10 22.6522 11.0536 25.1957 12.9289 27.0711C14.8043 28.9464 17.3478 30 20 30V30ZM20 0C20.3315 0 20.6495 0.131696 20.8839 0.366117C21.1183 0.600537 21.25 0.918479 21.25 1.25V6.25C21.25 6.58152 21.1183 6.89946 20.8839 7.13388C20.6495 7.3683 20.3315 7.5 20 7.5C19.6685 7.5 19.3505 7.3683 19.1161 7.13388C18.8817 6.89946 18.75 6.58152 18.75 6.25V1.25C18.75 0.918479 18.8817 0.600537 19.1161 0.366117C19.3505 0.131696 19.6685 0 20 0V0ZM20 32.5C20.3315 32.5 20.6495 32.6317 20.8839 32.8661C21.1183 33.1005 21.25 33.4185 21.25 33.75V38.75C21.25 39.0815 21.1183 39.3995 20.8839 39.6339C20.6495 39.8683 20.3315 40 20 40C19.6685 40 19.3505 39.8683 19.1161 39.6339C18.8817 39.3995 18.75 39.0815 18.75 38.75V33.75C18.75 33.4185 18.8817 33.1005 19.1161 32.8661C19.3505 32.6317 19.6685 32.5 20 32.5V32.5ZM40 20C40 20.3315 39.8683 20.6495 39.6339 20.8839C39.3995 21.1183 39.0815 21.25 38.75 21.25H33.75C33.4185 21.25 33.1005 21.1183 32.8661 20.8839C32.6317 20.6495 32.5 20.3315 32.5 20C32.5 19.6685 32.6317 19.3505 32.8661 19.1161C33.1005 18.8817 33.4185 18.75 33.75 18.75H38.75C39.0815 18.75 39.3995 18.8817 39.6339 19.1161C39.8683 19.3505 40 19.6685 40 20ZM7.5 20C7.5 20.3315 7.3683 20.6495 7.13388 20.8839C6.89946 21.1183 6.58152 21.25 6.25 21.25H1.25C0.918479 21.25 0.600537 21.1183 0.366117 20.8839C0.131696 20.6495 0 20.3315 0 20C0 19.6685 0.131696 19.3505 0.366117 19.1161C0.600537 18.8817 0.918479 18.75 1.25 18.75H6.25C6.58152 18.75 6.89946 18.8817 7.13388 19.1161C7.3683 19.3505 7.5 19.6685 7.5 20ZM34.1425 5.8575C34.3768 6.09191 34.5085 6.40979 34.5085 6.74125C34.5085 7.07271 34.3768 7.39059 34.1425 7.625L30.6075 11.1625C30.4913 11.2786 30.3533 11.3706 30.2016 11.4333C30.0498 11.4961 29.8871 11.5283 29.7229 11.5282C29.3912 11.528 29.0731 11.396 28.8387 11.1612C28.7227 11.045 28.6307 10.9071 28.5679 10.7553C28.5052 10.6035 28.4729 10.4409 28.4731 10.2766C28.4733 9.94491 28.6053 9.62689 28.84 9.3925L32.375 5.8575C32.6094 5.62316 32.9273 5.49152 33.2588 5.49152C33.5902 5.49152 33.9081 5.62316 34.1425 5.8575V5.8575ZM11.16 28.84C11.3943 29.0744 11.526 29.3923 11.526 29.7237C11.526 30.0552 11.3943 30.3731 11.16 30.6075L7.625 34.1425C7.38925 34.3702 7.07349 34.4962 6.74575 34.4933C6.418 34.4905 6.10449 34.359 5.87273 34.1273C5.64097 33.8955 5.50951 33.582 5.50666 33.2543C5.50381 32.9265 5.6298 32.6108 5.8575 32.375L9.3925 28.84C9.62691 28.6057 9.94479 28.474 10.2762 28.474C10.6077 28.474 10.9256 28.6057 11.16 28.84V28.84ZM34.1425 34.1425C33.9081 34.3768 33.5902 34.5085 33.2588 34.5085C32.9273 34.5085 32.6094 34.3768 32.375 34.1425L28.84 30.6075C28.6123 30.3717 28.4863 30.056 28.4892 29.7282C28.492 29.4005 28.6235 29.087 28.8552 28.8552C29.087 28.6235 29.4005 28.492 29.7282 28.4892C30.056 28.4863 30.3717 28.6123 30.6075 28.84L34.1425 32.375C34.3768 32.6094 34.5085 32.9273 34.5085 33.2588C34.5085 33.5902 34.3768 33.9081 34.1425 34.1425ZM11.16 11.1625C10.9256 11.3968 10.6077 11.5285 10.2762 11.5285C9.94479 11.5285 9.62691 11.3968 9.3925 11.1625L5.8575 7.625C5.73811 7.50969 5.64288 7.37176 5.57737 7.21926C5.51186 7.06675 5.47738 6.90273 5.47594 6.73675C5.47449 6.57078 5.50612 6.40618 5.56897 6.25256C5.63182 6.09894 5.72464 5.95937 5.84201 5.84201C5.95937 5.72464 6.09894 5.63182 6.25256 5.56897C6.40618 5.50612 6.57078 5.47449 6.73675 5.47594C6.90273 5.47738 7.06675 5.51186 7.21926 5.57737C7.37176 5.64288 7.50969 5.73811 7.625 5.8575L11.16 9.3925C11.2764 9.50861 11.3688 9.64655 11.4318 9.79842C11.4948 9.95028 11.5272 10.1131 11.5272 10.2775C11.5272 10.4419 11.4948 10.6047 11.4318 10.7566C11.3688 10.9084 11.2764 11.0464 11.16 11.1625V11.1625Z" fill="#ffffff"></path></svg>
                <svg class="changeTheme" data-theme="dark" width="38" height="40" viewBox="0 0 38 40" fill="black" xmlns="http://www.w3.org/2000/svg"> <path d="M15 0.695136C15.244 0.991667 15.3935 1.35457 15.4292 1.73694C15.4648 2.11932 15.385 2.5036 15.2 2.84014C13.7546 5.49382 12.9998 8.46837 13.005 11.4901C13.005 21.5426 21.2 29.6826 31.3 29.6826C32.6175 29.6826 33.9 29.5451 35.1325 29.2826C35.5103 29.2008 35.9039 29.2321 36.264 29.3726C36.6241 29.5131 36.9349 29.7566 37.1575 30.0726C37.3925 30.4013 37.5123 30.7983 37.4983 31.2021C37.4842 31.6058 37.3372 31.9936 37.08 32.3051C35.1192 34.7137 32.6456 36.6544 29.8396 37.9856C27.0335 39.3168 23.9658 40.0051 20.86 40.0001C9.335 40.0001 0 30.7151 0 19.2751C0 10.6651 5.285 3.28014 12.81 0.150136C13.1848 -0.00828447 13.601 -0.0407995 13.9959 0.057475C14.3908 0.15575 14.7431 0.379507 15 0.695136V0.695136Z" fill="#ff422e"></path></svg>
            </div>
            <script src="js/theme.js"></script>
            </div>
            <div class="botton-main-text">Welcome to my little universe...</div>
        <div class="nav-box">
            <ul>
                <li><a href="index.html">Главная</a></li>
                <li>/</li>
                <li><a href="#">C# CODE</a></li>
            </ul>
        </div>  

        <details>
            <summary>Герберт Шилдт C# 4.0. Полное руководство</summary>
            <div class="content">
              <ul>
                  <li><a href="#popup1" class="openmodalwindow">Основные сведения о среде .NET</a></li>
                  <li><a href="#popup2" class="openmodalwindow">Основные понятия в ООП</a></li>
                  <li><a href="#popup3" class="openmodalwindow">Типы данных, литералы и переменные</a></li>
                  <li><a href="#popup4" class="openmodalwindow">Введение в классы, объекты и методы</a></li>
                  <li><a href="#popup5" class="openmodalwindow">Подробнее о методах и классах</a></li>
                  <li><a href="#popup6" class="openmodalwindow">Открыть модальное окно</a></li>
              </ul>
            </div>
          </details>
          <details>
            <summary>Something</summary>
            <div class="content">
              <p>
                Lorem, ipsum dolor sit amet consectetur adipisicing elit. Modi unde, ex rem voluptates autem aliquid veniam quis temporibus repudiandae illo, nostrum, pariatur quae! At animi modi dignissimos corrupti placeat voluptatum!
                Facilis ducimus iure officia quos possimus quaerat iusto, quas, laboriosam sapiente autem ab assumenda eligendi voluptatum nisi eius cumque, tempore reprehenderit optio placeat praesentium non sint repellendus consequuntur? Nihil, soluta.
              </p>
            </div>
          </details>
           
    </div>

<!-- Основные сведения о среде .NET -->
    <div id="popup1" class="popup">
        <div class="popup_body">
            <div class="popup_content">
                <div class="popup_title"><h2>Основные сведения о среде .NET</h2></div>
                <div class="popup_text">
                   <p> Microsoft .NET  — объектно-ориентированная программная среда, где можно создавать, компилировать и исполнять код на различных платформах (Windows, Linux, MacOS). 
                    NET Framework состоит из двух основных составляющих:</p>
                    <br>
                    <ul>
                            <li><span>общеязыковая исполнительная среда CLR (Common Language Runtime).</span> <br> Управляемая среда выполнения предоставляет различные типы служб, такие как сборка мусора, проверка типов, обработка исключений, проверка границ и т.д., для автоматического кодирования без вмешательства программиста. Результатом компиляции программы на C# является не исполняемый код, а файл, содержащий псевдокод, называемый Microsoft Intermediate Language. Назначение CLR — преобразовать псевдокод в машинный код. Псевдокод MSIL преобразуется в машинный код с помощью <span>JIT-компилятора.</span> Компиляция осуществляется во время исполнения программы и подстраивается под архитектуру компьютера, обеспечивая переносимость кода.  </li>
                            <li><span>библиотека классов.</span> <br> Эта би­блиотека предоставляет программе доступ к среде выполнения. </li>
                    </ul>
                   <br> 
                   <div class="popup_title"><h2>Управляемый и неуправляемый код</h2></div>
                <p>Код, который написан для получения услуг выполнения управляемой среды выполнения, такой как CLR (Common Language Runtime) в .NET Framework, известен как управляемый код. Для того чтобы обработать такой код компилятор должен сформировать файл MSIL, используя при этом библиотеку классов .NET. Управляемый код обеспечивает независимость от платформы, поскольку, когда управляемый код компилируется на промежуточный язык, JIT-компилятор компилирует этот промежуточный язык в инструкции для конкретной архитектуры.</p>
                <br>   
                <p> Код, который непосредственно выполняется операционной системой, известен как неуправляемый код. Он всегда нацелен на архитектуру процессора и зависит от архитектуры компьютера. Он всегда компилируется в собственный код, специфичный для данной архитектуры.

                    В неуправляемом коде распределением памяти, безопасностью типов, безопасностью и т.д. управляет разработчик. Из-за этого возникает несколько проблем, связанных с памятью, таких как переполнение буфера, утечка памяти, переопределение указателя и т.д. Приложение, написанное на VB 6.0, C, C++ и т.д., всегда находится в неуправляемом коде. </p>
                   
                </div>
                <br>
                <a href="#" class="close-button" class="close">OK</a>
            </div>
        </div>
    </div>
<!-- Основные понятия в ООП -->
    <div id="popup2" class="popup">

        <div class="popup_body">
            <div class="popup_content">
                <div class="popup_title"><h2>Основные понятия в ООП</h2></div>
                <div class="popup_text">
                   <p> Все объектно-ориентированные языки програм­мирования, в том числе и С#, должны обладать тремя общими свойствами: инкапсу­ляцией, полиморфизмом и наследованием. </p>
                   <br>
                   <p><span>Инкапсуляция</span>  —  это механизм, позволяющий объединить данные и код в некий черный ящик, называемый классом, и на основе этого класса создать объект или экземпляр класса, наделив его особыми характеристиками, отличными от других объектов.</p>
                   <br>
                    <p>Код и данные могут быть как закрытыми, так и открытыми. Закрытые данные или код недоступны части программы,
                    находящейся за пределами объекта. Открытые данные и код доступны другим частям программы.</p>
                    <br>
                    <p>Код и данные, составляющие вместе класс, называют членами класса Данные, определяе­мые классом, также именуются <div class="block"><div class="hover">данными-членами</div>
                        <div class="hidden">
                            К данным-членами относятся:
                            <ul>
                                <li>поля   —   любые переменные, связанные с классом</li>
                                <li>константы   —  поля, объявленные с модификатором const.</li>
                                <li>события   —  члены класса, позволяющие объекту уведомлять вызывающий код о том, что произошло какое-то событие</li>
                            </ul>
                       </div></div>. 
                        А код, манипулирующий данными-членами называется <div class="block"><div class="hover">функцией-членом </div>
                        <div class="hidden">    К функциям-членам относятся: 
                            <ul>
                                <li>Методы   —  функции, определяющие поведение экземпляров класса</li>
                                <li>Свойства   —  предоставляют доступ к закрытым членам-данным посредством get, set</li>
                                <li>Конструкторы (инициализируют экземляры класса) и Финализаторы</li>
                                <li>Арифметические и Логические операции</li>
                                <li>Индексаторы   —  позволяют обращаться с объектом класса так, как будто он является массивом</li>
                            </ul>
                         </div></div>. 
                    </p>
                    
                        
                        
                    
                
                <br>
                   <p><span>Полиморфизм</span>  — это способность программы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Полиморфизм помогает
                    упростить программу, позволяя использовать один и тот же интерфейс для описания
                    общего класса действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования.  </p>
                   <br>
                   <p><span>Наследование</span> — процесс, в ходе которого один объект приобре­тает свойства другого объекта. Если не использовать наследование, то для каждого объекта придется явно опре­делять все его свойства. В то время как при использовании наследования достаточно опреде­лить лишь те свойства, которые делают объект особенным в его классе.<div class="block"><div class="hover">Пример</div><div class="hidden">Например, сорт яблок "Джонатан" входит в общую классификацию сортов яблок,
                        которые, в свою очередь, относятся к классу фруктов, а те — к еще более крупному
                        классу пищевых продуктов. Cорт яблок "Джонатан" на­следует свойства всех предшествующих классов, обладая в то же время свойствами,
                        присущими только этому сорту яблок, например характерным ароматом и вкусом.</div></div>
                </p>
                </div>
                <br>
                <a href="#" class="close-button" class="close">OK</a>
            </div>
        </div>
    </div>
<!-- Типы данных, литералы и переменные -->
    <div id="popup3" class="popup">
        <div class="popup_body">
            <div class="popup_content">
                <div class="popup_title"><h2>Типы данных, литералы и переменные</h2></div>
                <div class="popup_text">
                   <p> <span>Переменная</span> — это именованная область памяти, для которой может быть уста­новлено значение. Она называется переменной потому, что ее значение может быть
                    изменено по ходу выполнения программы.</p>
                    <br>
                    <p> <span>Литерал</span> — это числовое, символьное, строковое или логическое значение, которое может быть присвоено переменной или <div class="block"><div class="hover">константе</div><div class="hidden">int a = 10. int - тип. a - переменная. 10 - литерал.</div></div>.</p>
                    <br>
                    <p>В C# имеются две общие категории встроенных типов данных: 
                        <ul>
                            <li>типы значений</li>
                            <li>ссы­лочные типы</li>
                        </ul>
                        Они отличаются по содержимому переменной. Если переменная от­носится к типу значения, то она содержит само <div class="block"><div class="hover">значение</div>
                        <div class="hidden">
                            То есть при инициализации переменной типа значения для ее хранения выделяется определенная ячейка памяти
                            которая хранит само значение.
                            Если произвести присваивание одной переменной другой, то для этой переменной создастся копия значения исходной переменной, но при этом переменная
                            которой присвоили значение не будет располагаться в той же ячейке памяти, что и исходная. Из этого следует, что 
                            при изменении первоначального значения исходной переменной, эти изменения никак не отразятся на копии, то же самое и наоброт.
                            <br>
                            int a = 10;
                            <br>
                            int b = a; 
                            <br>
                            b = 20;
                            <br>
                            Console.Writeline(a); //10 
                        </div>
                    </div>. Если переменная относится к ссылочному типу, то она содержит <div class="block"><div class="hover">ссылку на значение</div> <div class="hidden">
Если две переменные ссылаются на один и тот же объект при изменении значения в одной переменной меняется значение другой переменной, тоже самое и наоборот.
<br>
Demo x = new Demo();
<br>
x.MyValue = 10;
<br>
Demo y = x;
<br>
y.MyValue = 20; // после этого оба x.MyValue и y.myValue равны 20

                    </div></div>.
                </p> 
                        
                        <br>
                        <p>В языке С# существует 13 типов значений. Все они называются простыми типами, поскольку состоят из единственного значения.
                            (Иными словами, они не состоят из двух или более значений.) Простые типы данных иногда еще называют <span>при­митивными </span>.
                            Помимо простых типов, в C# определены еще три категории типов значений: перечисления, структуры и обнуляемые типы.
                        </p>
                        <br>
                        <p><span>Неявно типизированными</span> называются такие переменные, тип которых автоматически определяется
                            компилятором. Неявно типизированная переменная объявляется с помощью ключевого слова <span>var</span> 
                            и должна быть инициализирована. Как только компилятор определит тип переменной его нельзя будет изменить по ходу выполнения программы.
                            Одновременно можно объявить только одну неявно типи­зированную переменную.
                        </p>
                        <br>
                        <div class="popup_title"><h2>Область действия и время существования переменных</h2></div>
                        <p>Локальными переменными называются переменные, объявленные внутри метода.</p>
                        <br>
                        <p>Кодовый блок начинает­ся открывающей фигурной скобкой и оканчивается закрывающей фигурной скобкой.
                            Этот блок определяет <span>область действия</span> переменной.
                            Всякий раз, когда начинается
                            блок, образуется новая область действия. Эта область определяет также время существования
                            локальных переменных.
                        </p>
                        <br>
                        <p>Области действия переменных можно разделить на три категории:</p>
                        <ul>
                            <li>Область действия уровня класса</li>
                            <li>Область действия уровня метода </li>
                            <li>Область действия уровня блока</li>
                        </ul>
                        <br>
                        <p>Область действия, определяемая <span>методом</span>, начинается открывающей фигурной
                            скобкой и оканчивается закрывающей фигурной скобкой. Если у метода име­ются параметры, то они также входят в область действия, определяемую данным методом.
                            Локальные переменные объявленные внутри метода, имеют область действия на уровне метода. Они недоступны вне метода.
                        </p>
                        <br>
                        <p>Области действия метода могут быть вложенными. Например, всякий раз, когда создается
                            кодовый блок, одновременно образуется и новая, вложенная область действия. В этом
                            случае внешняя область действия охватывает внутреннюю область. Это означает, что
                            локальные переменные, объявленные во внешней области действия, будут видимы для
                            кода во внутренней области действия. Но обратное не справедливо: локальные перемен­
                            ные, объявленные во внутренней области действия, не будут видимы вне этой области.</p>
                            <br>

                            <pre><code class="cs">
using System;

namespace one
{
    class Program
    {
        static void Main(string[] args)
            {
                int x = 10; 
// Эта переменная доступна для всего кода внутри метода Main()
                if (x==10)
// Начинается новая область действия
                {
            int y = 20;
// Эта переменная доступна только в данном кодовом блоке.
            Console.WriteLine($&quot;{x} + {y} = {x+y}&quot;);
// Здесь доступны обе переменные, х и у.
            x = y*2;
                }

                y = 100;
// Ошибка! Переменная y здесь недоступна.

                Console.WriteLine($&quot;x - {x}&quot;);
// А переменная х здесь по-прежнему доступна.
            }
    }
}
                </code></pre>
                <br>
                <div class="popup_title"><h2>Преобразование и приведение типов</h2></div>
                <br>
                <p>Когда переменная одного типа присваивается переменной другого типа, неявное преоб­разование типов происходит при следующих условиях:
                    <ul>
                        <li>оба типа <div class="block"><div class="hover">совместимы</div><div class="hidden">
                            
                            Два типа считаются совместимыми, если:
                            <ul>
                                <li>Оба типа есть один и тот же тип;</li>
                                <li>Оба типа вещественные</li>
                                <li>Оба типа целые</li>
                                <li>Один тип - вещественный, второй тип - целый (целый тип присваевается к вещественному, но не наоборот)</li>
                            </ul>
                            Все остальные типы несовместимы друг с другом. Для них требуется явное преоб­разование.
                        </div></div>;</li>
                        <li>диапазон представления чисел целевого типа шире, чем у исходного типа.</li>
                    </ul>
                    <p>Например, тип int достаточно крупный, чтобы вмещать в себя все действительные
                        значения типа byte, а кроме того, оба типа, int и byte, являются совместимыми цело­численными типами, и поэтому для них возможно неявное преобразование.</p>
                </p>
                    <br>
                    <p>Преобразование несовместимых типов может быть осуществлено
                        путем <span>приведения</span>. Приведение типов означает явное преобразова­ние.</p>
                        <br>
                        <p>
                            Ниже приведена общая форма приведения типов.</p>
                            <br>
<p><span><div class="block"><div class="hover">(целевой_тип) выражение</div>
    <div class="hidden">
        <p>float a = 10.05F;</p>
        <p>int b = (int)a; > 10</p>
        <br>
        <p>int a = 257;</p>
        <p>byte b = (byte)a; > 1</p>
        <br>
        <p>ushort a = 64000;</p>
        <p>short b = (short) a; > -1536 </p>
        <br>
        <p>byte a = 88; // код ASCII символа X</p>
        <p>char b = (char) a; > X</p>
        
    </div>
</div>
</span></p>
<br>
<p>Здесь <span>целевой_тип</span> обозначает тот тип, в который желательно преобразовать ука­занное <span>выражение</span>.</p>
<br>
<p>После проведения явного преобразова­ния часть информации может быть утеряна. 
    Например, когда значение с плавающей точкой приводится к целочислен­ному типу, то в результате усечения теряется дробная часть этого числового значения.</p>

                        
                </div>
                
                <br>
                <a href="#" class="close-button" class="close">OK</a>
            </div>
        </div>
    </div>
<!-- Введение в классы, объекты и методы -->
    <div id="popup4" class="popup">
        <div class="popup_body">
            <div class="popup_content">
                <div class="popup_title"><h2>Введение в классы, объекты и методы</h2></div>
                <div class="popup_text">
                   <p>При определении класса объявляются данные, которые он содержит, а также код,
                    оперирующий этими данными. Данные содержатся в членах-данных, определяемых классом, а код —
                    в функциях-членах.</p>
                    <br>
                    <p>Класс создается с помощью ключевого слова <span>class</span>. Перед каждым объявлением поля и метода
                        указывается спецификатор доступа, например public, определяющий
                        порядок доступа к данному члену класса. По умолчанию спецификатор доступа считается закрытым (private). 
                        Члены с закрытым доступом могут ис­пользоваться только другими членами их класса. 
                    </p>
                    <br>
                    <pre><code>
class имя_класса {
        // Объявление переменных экземпляра.
        доступ тип переменная1;
        доступ тип переменная2;
        //...
        доступ тип переменнаяN;
        // Объявление методов.
        доступ возращаемый_тип метод1(параметры) {
        // тело метода
        }
        доступ возращаемый_тип метод2(параметры) {
        // тело метода
        }
        // ...
        доступ возращаемый_тип методы(параметры) {
        // тело метода
        }
}
                    </code></pre>
                    <br>
                    <p>Для того чтобы создать конкретный объект класса, нужно воспользо­ваться следующим оператором.</p>
                    <br>
                    <p><span>имя_класса имя_объекта = new имя_класса();</span></p>
                    <br>
                    
                    <p>Класс считается ссылочным типом. Это значит, что при инициализации объекта объявляется переменная, которая 
                        не является объектом, но может ссылаться на этот объект. Оператор new динамически (т.е. во время выполнения) 
                        распределяет память для объ­екта и возвращает ссылку на него, которая затем сохраняется в переменной.  Для получения доступа к этой переменной существует оператор доступа к члену класса, который принято называть оператором-точкой. Оператор-точка связывает имя объекта с именем члена класса. Ниже приведе­на общая форма оператора-точки.</p>
               <br>
               <p><span>имя_объекта.имя_члена_класса</span></p>
               <br>
               <p>
                В операции присваивания переменные ссылочного типа действуют иначе, чем 
пе­ременные типа значения, например типа int. Когда одна переменная типа значения
присваивается другой, переменная, находя­щаяся в левой части оператора присваивания, получает копию значения переменной,
находящейся в правой части этого оператора. Когда же одна переменная ссылки на
объект присваивается другой, то ситуация несколько усложняется, поскольку такое
присваивание приводит к тому, что переменная, находящаяся в левой части оператора
присваивания, ссылается на тот же самый объект, на который ссылается переменная,
находящаяся в правой части этого оператора(т.е переменная получает ссылку ссылки на объект). Сам же объект не копируется. В силу
этого отличия присваивание переменных ссылочного типа может привести к 
несколь­ко неожиданным результатам. В качестве примера рассмотрим следующий фрагмент
кода.
            
            </p>
            <br>
            <pre><code class="cs">
Building house1 = new Building();
Building house2 = house1;
            </code></pre>
            <br>
            <p>
                На первый взгляд, кажется, что переменные house1 и house2 ссылаются на совершенно разные
объекты, но на самом деле это не так. Переменные house1 и house2, напротив, 
ссы­лаются на один и тот же объект. Когда переменная house1 присваивается переменой
house2, то в конечном итоге переменная house2 просто ссылается на тот же самый 
объ­ект, что и переменная house1. Несмотря на то что обе переменные, house1 и house2, ссылаются на один и тот же
объект, они никак иначе не связаны друг с другом. Например, в результате следующей
последовательности операций присваивания просто изменяется объект, на который
ссылается переменная house2.
            </p>
            <br>
            <pre>
                <code class="cs">
Building house1 = new Building();
Building house2 = house1;
Building house3 = new Building();
house2 = house3; 
// теперь обе переменные, house2 и house3
// ссылаются на один и тот же объект.
                </code>
            </pre>
            <br>
            <p>После выполнения этой последовательности операций присваивания 
                перемен­ная house2 ссылается на тот же самый объект, что и переменная house3. А ссылка на
                объект в переменной house1 не меняется.</p>
                <br>
                <p><span>Методы</span>
                    представляют собой подпрограммы, которые манипулируют данными, 
                    определенны­ми в классе. 
                    Как прави­ло, другие части программы взаимодействуют с классом посредством его методов.</p>
                    <br>
                    <p>Ниже приведена общая форма определения метода:</p>
                    <br>
                    <pre>
                        
                        <code>доступ возращаемый_тип имя(список_параметров) {
// тело метода
}
</code>
                </pre>
                    <br>
                    <p>возращаемый_тип обозначает тип данных, возвращаемых методом. Этот тип должен
                        быть действительным с типом создаваемого класса. Если метод не возвра­щает значение, то в качестве возвращаемого типа для него следует указать тип void.</p>
                      <br> <p> список_параметров — это последовательность пар, со­стоящих из типа и идентификатора, разделенных запятыми. Параметры представляют
                        собой переменные, получающие значение аргументов, передаваемых методу при его 
                        вы­зове. 
                        Если у метода отсутствуют параметры, то список параметров оказывается пустым.
                    </p>
                    <br>
                    <p>Если в методе используется переменная
экземпляра, определенная в его классе, то делается это непосредственно, без указания
явной ссылки на объект и без помощи оператора-точки.
                    </p>
                    <br>
                    <div class="popup_title"><h2>Возврат из метода</h2></div>
                    <br>
                    <p>Для немедленного завершения метода типа <span>void </span> достаточно воспользоваться
                        оператором return.</p>
                        <br>
                        <p>Когда выполняется этот оператор, управление возвращается вызывающей части
                            программы, а оставшийся в методе код пропускается. В качестве примера рассмотрим
                            следующий метод.</p>
                            <br>
                            <pre><code>
int i;
    for(i=0; i&lt;10; i++) 
    {
        if(i == 5) return; // прервать на шаге 5
        Console.WriteLine();
    }
}
                            </code></pre>
                            <br>
                            <p>Методы с возвратом типа void нередко применяются в программировании, тем
                                не менее, большинство методов возвращает конкретное значение.

                                Для возврата значения из метода в вызывающую часть программы служит 
                                следующая форма оператора return:
                            </p>
                            <br>
                            <p><span>return значение;</span></p>
                            <br>
                            <p>При вызове метода ему можно передать одно или несколько значений. Значение,
                                передаваемое методу, называется <span>аргументом</span>. А переменная, получающая аргумент,
                                называется формальным параметром, или просто<span> параметром</span>.
                                Параметры 
                                объявляются 
                                в скобках после имени метода.
                            </p>
                            <br>
                            <div class="popup_title"><h2>Конструктор</h2></div>
                            <br>
                            <p>
                                Конструктор инициализирует объект при его создании. У конструктора такое же
                                имя, как и у его класса, а синтаксически он подобен методу. Но у 
                                конструк­торов нет возвращаемого типа, указываемого явно.  
                            </p>
                            <br>
                            <p>
                                
                                У каждого класса есть конструктор, где используются значения по умолчанию.
                                Для большинства типов данных значением по умолчанию является 
                                нулевое, для типа bool — значение false, а для ссылочных типов — пустое значение.
Как только определится собственный конструктор, конструктор со значениями по умолчанию перестанет использоваться.
                            </p>
                            <br>
                            <p>В конструктор параметры вводятся таким же образом,
                                как и в метод. Для этого достаточно объявить их в скобках после имени конструктора.
                                Ниже приведен пример применения параметризированного конструктора MyClass.</p>
                            <br>
                            <pre><code>
using System;

namespace one
{
    class Program
    {
        static void Main(string[] args)
        {
            Demo girl = new Demo(&quot;Alena&quot;); //параметру name передается значение, которое затем присваивается переменной Name.
            Demo boy = new Demo(&quot;Lesha&quot;);

            Console.WriteLine($&quot;{girl.Name} and {boy.Name} are the best friends!&quot;);
        }
    }

    class Demo
    {
        public string Name;

        public Demo(string name)
        {
            Name = name;
        }
    }
}
                            </code></pre>
                            <br>
                            <p>Когда метод вызывается, ему автоматически передается ссылка на вызывающий
                                объект, т.е. тот объект, для которого вызывается данный метод. Эта ссылка
                                обозначается ключевым словом <span>this</span>. 
                                
                                В синтаксисе C#
                                допу­скается называть параметр или локальную переменную тем же именем, что и у­
                                переменной экземпляра. В этом случае имя локальной переменной скрывает переменную
экземпляра. Для доступа к скрытой переменной экземпляра и служит ключевое слово
this.
                                 </p>
                            <br>
                            <pre><code>
public Demo(int Velocity, int Time)
        {
            this.Velocity = Velocity;
            this.Time = Time;
        }
                            </code></pre>
                    </div>
       
                <br>
                <a href="#" class="close-button" class="close">OK</a>
            </div>
        </div>
    </div>
<!-- Подробнее о методах и классах -->
    <div id="popup5" class="popup">

        <div class="popup_body">
            <div class="popup_content">
                <div class="popup_title"><h2>Подробнее о методах и классах</h2></div>
                <div class="popup_text">
                   <p>
                    Управление доступом в языке C# организуется с помощью четырех модификаторов
                    доступа: <span>public</span>, <span>private</span>, <span>protected</span> и <span>internal</span>.
                   </p> 
                   <br>
                   <p>
                    Когда член класса обозначается спецификатором <span>public</span>, он становится 
                    доступ­ным
                     из любого другого кода в программе, включая и методы, определенные в других
                    классах. Когда же член класса обозначается спецификатором <span>private</span>, он может быть
                    доступен только другим членам этого класса.
                   </p>
                   <br>
                   <p>
                    Основные принципы организации открытым и закрытым доступом:
                    <ul>
                        <li>Члены, используемые только в классе, должны быть закрытыми.</li>
                        <li>Если изменение члена оказывает влияние на другие аспекты объ­екта
                    , то этот член должен быть закрытым, а доступ к нему контролируемым.</li>
                        <li>Члены, способные нанести вред объекту, если они используются неправильно,
                    должны быть закрытыми. Доступ к этим членам следует организовать с помо­щью 
                    открытых методов, исключающих неправильное их использование.</li>
                        <li>Методы, получающие и устанавливающие значения закрытых данных, должны
                    быть открытыми.</li>
                        <li>Переменные экземпляра допускается делать открытыми лишь в том случае, если нет никаких оснований для того, чтобы они были закрытыми.</li>
                    </ul>
                   </p>
                   <br>
                   <p>
                    Аргументы простых типов, например int или char, ­
                    передаются методу по значению. Это означает, что изменения, вносимые в параметр, 
                    прини­мающий значение, не будут оказывать никакого влияния на аргумент, используемый
                    для вызова. Но такое поведение можно изменить, используя ключевые слова ref и out
                    для передачи значений обычных типов по ссылке.Это позволяет изменить в самом
                    методе аргумент, указываемый при его вызове.
                   </p>
                   <br>
                    <p>Модификатор параметра <span>ref</span>  принудительно организует вызов по ссылке, а не по
                    значению. Этот модификатор указывается как при объявлении, так и при вызове мето­да.
                    Аргументу,
передаваемому по ссылке с помощью этого модификатора, должно быть присвоено
значение до вызова метода. 
                    </p>
                   <br>
                   <pre><code>
using System;

namespace one
{
    class Demo
    {
        public void Swap(ref int a, ref int b)
        {
            int t; //t = 0, a = 10, b = 20
            t = a; //t = 10, a = 10, b = 20
            a = b; //t = 10, a = 20, b = 20
            b = t; //t  10, a = 20, b = 10
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            int y = 20;

            Console.WriteLine(x); //10
            Console.WriteLine(y); //20

            Demo dm = new Demo();

            dm.Swap(ref x, ref y);
            
            Console.WriteLine(x); //20
            Console.WriteLine(y); //10
        }
    }
}
                   </code></pre>
                   <br>
                   <p>
                    Модификатор параметра <span>out</span> подобен модификатору ref, за исключением того, что ref требует инициализации переменной перед передачей аргументов (параметров) по ссылке.
                    Перемен­ной
                    , используемой в качестве параметра out, не нужно присваи­вать какое-либо значение.
                   </p>
                   <br>
                   <pre><code>
using System;

namespace one
{
    class Program
    {
        //Программа возвращает целую часть и дробную

        static void Main(string[] args)
        {
            double n = 10.25;
            double f;
            int i = Hello(n, out f);
            Console.WriteLine(i); //10
            Console.WriteLine(f); //0,25
        }

        static public int Hello(double n, out double f)
        {
            int whole;

            whole = (int)n;
            f = n - whole;
            return whole; 
        }
    }
}
                   </code></pre>
                   <br>
                   <p>
                    Для объявления массива параметров, способного принимать от нуля до нескольких
                    аргументов, служит модификатор <span>params</span>.  Число элементов массива параметров 
                    бу­дет равно числу аргументов, передаваемых методу. А для получения аргументов в
                     про­грамме организуется доступ к данному массиву. В тех случаях, когда у метода имеются параметры примитивных типов, а также параметр
                     типа params, он должен быть указан последним в списке параметров метода.
                   </p>
                   <br>
                   <pre><code>
using System;

namespace one
{
    class Demo
    {
        //Программа ищет минимальное число в массиве
        public int MinValue(params int[] nums)
        {
            int m = nums[0];

            for (int i = 0; i &lt; nums.Length; i++)
            {
                if (nums[i] &lt; m)
                {
                    m = nums[i];
                }
            }

            return m;
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Demo mv = new Demo();

            int min = mv.MinValue(1,2);
            Console.WriteLine(min); //1
            min = mv.MinValue(3,4,5,6);
            Console.WriteLine(min); //3
            int[] array = new int[] {5,4,6,7};
            min = mv.MinValue(array);
            Console.WriteLine(min); //4
        }
    }
}
                   </code>
                </pre><br>
                <p>В языке программирования C# допускается совместное использование одного и того же имени двумя или бо­лее
                    методами одного и того же класса, при условии, что их параметры объявляются <div class="block"><div class="hover">по-разному</div><div class="hidden">тип или число параметров у каждого метода должны быть разными.</div></div>
                    
                    
                    . В этом случае говорят, что методы перегружаются, а сам процесс называ­ется
                    <span>перегрузкой методов</span>. Когда
                    вызывается перегружаемый метод, то выполняется тот его вариант, параметры кото­рого 
                    соответствуют (по типу и числу) передаваемым аргументам.</p>
                    <br>
                    <pre><code>
using System;

namespace one
{
    class MyClass
    {
        public void IntroduceYourSelf()
        {
            Console.WriteLine("Отвали!");
        }

        public void IntroduceYourSelf(string name)
        {
            Console.WriteLine($"Меня зовут {name}.");
        }

        public void IntroduceYourSelf(string name, int age)
        {
            Console.WriteLine($"Меня зовут {name}, мне {age} лет.");
        }

    }
    class Program
    {
        static void Main(string[] args)
        {
            MyClass human = new MyClass();
            human.IntroduceYourSelf();
            human.IntroduceYourSelf("Катя");
            human.IntroduceYourSelf("Катя", 18);            
        }
    }
}
                    </code></pre>
                    <br>
                    <p><span>Инициализаторы объектов</span> предоставляют еще один способ создания объекта и ини­циализации
                         его полей и свойств. Если
                        используются инициализаторы объектов, то вместо обычного вызова конструктора
                        класса указываются имена полей или свойств, инициализируемых первоначально задаваемым­
                         значением. Cинтаксис инициализатора объекта предоставляет
                        альтернативу явному вызову конструктора класса.</p>
                    <br>
                    <pre><code>
using System;

namespace one
{
    class Demo
    {
        public int Count;
        public string Str;
    }
    class Program
    {
        static void Main(string[] args)
        {
            Demo person = new Demo { Str = "программирование это про", Count = 100 };
            Console.WriteLine($"{person.Str}{person.Count}");
        }
    } // программирование это про100
}
                    </code></pre>
                    <br>
                </div>
                <br>
                <a href="#" class="close-button" class="close">OK</a>
            </div>
        </div>
    </div>

    <div id="popup6" class="popup">

        <div class="popup_body">
            <div class="popup_content">
                <div class="popup_title"><h2>Четвертое окно</h2></div>
                <div class="popup_text">
                   <p> Привет!</p>
                </div>
                <pre><code class="html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ru&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
&lt;title&gt;Заголовок&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
                        
                        
&lt;/body&gt;
&lt;/html&gt;
                </code></pre>
                <br>
                <a href="#" class="close-button" class="close">OK</a>
            </div>
        </div>
    </div>



<script src="js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad('cs','html');</script>
<script src="js/scripts.js"></script>
    
</body>
</html>